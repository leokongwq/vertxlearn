package com.leokongwq.vertx.microservice.common.service;

import org.apache.commons.collections4.CollectionUtils;

import java.util.Collections;
import java.util.List;
import java.util.Optional;

import io.vertx.core.AsyncResult;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.SQLConnection;
import io.vertx.ext.sql.SQLOptions;
import io.vertx.ext.sql.UpdateResult;

/**
 * @author : kongwenqiang
 * DateTime: 2017/11/30 下午5:11
 * Mail:kongwenqiang@qiyi.com   
 * Description: desc
 */
public class JdbcRepositoryWrapper {

    protected final JDBCClient client;

    public JdbcRepositoryWrapper(Vertx vertx, JsonObject config) {
        this.client = JDBCClient.createNonShared(vertx, config);
    }

    /**
     * insert a row
     * @param sql insert sql
     * @param param insert parameter
     * @return the inserted row id
     */
    protected Future<Long> insert(String sql, JsonArray param) {
        Future<UpdateResult> updateFuture = this.doUpdate(sql, param);
        return updateFuture.map(updateResult -> updateResult.getKeys().getLong(0));
    }

    /**
     * execute update sql
     * @param sql the update sql
     * @param param the update sql parameters
     * @return the affected rows of this update sql
     */
    protected Future<Integer> update(String sql, JsonArray param) {
        Future<Integer> future = Future.future();
        Future<UpdateResult> updateFuture = doUpdate(sql, param);
        updateFuture.setHandler(as -> {
            if (updateFuture.succeeded()) {
                future.complete(updateFuture.result().getUpdated());
            } else {
                future.fail(updateFuture.cause());
            }
        });
        return future;
    }

    /**
     * query the specific row by condition
     * @param sql the query sql
     * @param param the query parameters
     * @return return the record if exist
     */
    protected Future<Optional<JsonObject>> queryOne(String sql, JsonArray param) {
        return getConnection().compose(connection -> {
            Future<Optional<JsonObject>> future = Future.future();
            connection.queryWithParams(sql, param, ar -> {
                if (ar.succeeded()) {
                    List<JsonObject> resList = ar.result().getRows();
                    if (CollectionUtils.isEmpty(resList)) {
                        future.complete(Optional.empty());
                    } else {
                        future.complete(Optional.of(resList.get(0)));
                    }
                } else {
                    future.fail(ar.cause());
                }
                connection.close();
            });
            return future;
        });
    }

    /**
     * query the specific row by condition
     * @param sql the query sql
     * @param param the query parameters
     * @return return the record if exist
     */
    protected Future<List<JsonObject>> queryList(String sql, JsonArray param) {
        return getConnection().compose(connection -> {
            Future<List<JsonObject>> future = Future.future();
            connection.queryWithParams(sql, param, ar -> {
                if (ar.succeeded()) {
                    List<JsonObject> resList = ar.result().getRows();
                    if (CollectionUtils.isEmpty(resList)) {
                        future.complete(Collections.emptyList());
                    } else {
                        future.complete(resList);
                    }
                } else {
                    future.fail(ar.cause());
                }
                connection.close();
            });
            return future;
        });
    }

    /**
     * 执行更新
     * @param sql 需要执行的修改SQL语句
     * @param param SQL 语句参数
     * @return 更新结果
     */
    private Future<UpdateResult> doUpdate(String sql, JsonArray param) {
        return getConnection().compose(connection -> {
            connection.setOptions(new SQLOptions().setAutoGeneratedKeys(true));
            Future<UpdateResult> future = Future.future();
            connection.updateWithParams(sql, param, ar -> {
                if (ar.succeeded()) {
                    future.complete(ar.result());
                } else {
                    future.fail(ar.cause());
                }
                connection.close();
            });
            return future;
        });
    }

    /**
     * A helper methods that generates async handler for SQLConnection
     * @param errHandler the fail Handler for the SQLConnection
     * @param connHandler the success Handler for the SQLConnection
     * @return generated handler
     */
    protected <R> Handler<AsyncResult<SQLConnection>> connHandler(Handler<AsyncResult<R>> errHandler, Handler<SQLConnection> connHandler) {
        return as -> {
            if (as.succeeded()) {
                final SQLConnection connection = as.result();
                connHandler.handle(connection);
            } else {
                errHandler.handle(Future.failedFuture(as.cause()));
            }
        };
    }

    /**
     * get a SQLConnection
     * @return SQLConnection
     */
    protected Future<SQLConnection> getConnection() {
        Future<SQLConnection> future = Future.future();
        client.getConnection(future.completer());
        return future;
    }
}

